
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
<script>
// 1. hoisting : 끌어올리다라는 의미 
// 자바스크립트에서는 선언된 함수나 변수를 상단부로 끌어올린 후 사용한다는 의미
// 변수의 범위가 전역인지 함수인지에 따라 호이스팅은 다르게 설정된다.
// 전역 범위 : 전체 코드의 최상단부
// 함수 범위 : 해당 함수의 최상단부
// 호이스팅은 함수와 변수의 정의도 함께 상단으로 끌어올리는 것이 아니고
// 단순히 선언부만 끌어올리기 떄문에 정의가 되지 않은 변수나 함수를 출력 또는 사용시 undefined가 된다.
// 자바스크립트는 비동기처리를 하므로 코드가 수행되는 동안 다음 줄의 코드로 넘어갈 수 있다.
// 예시

noDefined();    // 정상 출력 

function noDefined(){
    console.log('not defined : ' + name)
    var name = 'James';
    console.log('Defined : '+ name)
}

// 같은 결과의 코드 
function noDefined() {
    var name;
    console.log('not defined : ' + name)
    name = 'James';
    console.log('Defined : ' + name)
}


// 결과
// undefined
// Defined : James

// 처음에 스크립트가 실행될 떄 
// 전역범위에서 noDefined함수가 먼저 선언되고,
// noDefined()함수가 실행될 때 name이 선언된다.
// 첫번째는 함수의 정의는 되었으나, name이 정의되지 않아 undefined이 출력됨
// 두번쨰는 name의 데이터를 정의했기 떄문에 모두 출력

// 함수 선언식일때는 함수 선언부+정의부가 모두 함께 호이스팅된다.
// 그러므로 함수호출이 함수 정의보다 먼저 작성하더라도 문제가 없지만
// 함수 표현식에서는 함수를

// hoisting 예시
// func1();    //  오류 발생
var func1 = function f1(){  // 기명함수 표현식
    console.log('함수 표현식')
}
// 또는
var func2 = function(){     // 익명함수 표현식 
    console.log('함수 표현식')
}
func1();
// 이런식으로 작성하는데,
// 이 둘은 모두 func1과 func2가 먼저 호이스팅 되므로
// 함수의 정의보다 호출이 먼저 나오면 오류가 발생한다.

// 함수 표현식의 호이스팅 순서
var func3 = function(){
    var str = 'hello world';
    console.log(str)
}
// 같은 코드
var func3;  // 전역범위의 호이스팅
func3 = function () {
    var str;    // 함수범위의 호이스팅
    str = 'hello world';
    console.log(str)
}

// 참고 : 협업시 디버깅이 용이하기 때문에 더글라스 클라포드는 함수 선언문보다는 함수 표현식을 권장했고
//       ES6로의 업데이트 이후, 디버깅에 있어 기명 함수 표현식의 이점이 어느정도 해결되었기 때문에
//       익명함수 표현식을 사용하는 것을 권장함.
// 또한, ES6에서는 Arrow function과 같이 function임을 명시하지 않아도 함수를 만들 수 있음.

</script>
</body>
</html>